////////////////////////////////////////////////////////////////////////////////

!Trigger Group (open): Activate at 'Feeding' stage
  -engageTrigger (run external logic)

{
    //trigger.activationState = 'Feeding'
  if(state.current == trigger.activationState)
  {
    engageEntireTrigger();
  }
}

////////////////////////////////////////////////////////////////////////////////

Feeding:
  -bolt beginning to close (animation + sound)
  -transitionRoundFromMagToBolt (transfer of object)

{
  animation* boltAnimation = BoltPos<animation>(boltPosFeeding);
  BindEvent(boltAnimation, END, transitionRoundFromMagToBolt);

  playAnimation(boltAnimation);
  playSound(BoltPos<sound>(boltPosFeeding));

  state.next();
}

////////////////////////////////////////////////////////////////////////////////

Chambering:
  -bolt finsihing to close (animation + sound)
  -transitionRoundFromBoltToChamber (transfer of object)

{
  animation* boltAnimation = BoltPos<animation>(boltPosChambering);
  BindEvent(boltAnimation, END, transitionRoundFromBoltToChamber);

  playAnimation(boltAnimation);
  playSound(BoltPos<sound>(boltPosChambering));

  state.next();
}

////////////////////////////////////////////////////////////////////////////////

*Locking:
  -*ensuring bolt is closed (logic check)
  -locking bolt (animation + sound)

{
    //float distanceForLocking - 
  if(bolt.distanceFromClosed() < bolt.distanceForLocking)
  {
    playAnimation(BoltPos<animation>(boltPosLocking));
    playSound(BoltPos<sound>(boltPosLocking));

    state.next();
  }
}

////////////////////////////////////////////////////////////////////////////////

!Trigger Group (close): Activate at 'Firing' stage
  -engageTrigger (run external logic)

{
    //trigger.activationState = 'Firing'
  if(state.current == trigger.activationState)
  {
    engageEntireTrigger();
  }
}

////////////////////////////////////////////////////////////////////////////////

Firing:
  -*engage hammer (animation + sound)
  -activateRoundInChamber (activate external system)
  -if successful: continue
  -else: don't continue

{
  playAnimation(HammerPos<animation>(hammerPosEngaged));
  playSound(HammerPos<sound>(hammerPosEngaged));

  if(activateRoundInChamber())
  {
    state.next(); //SetState("Firing", AFTER);
  }
}

////////////////////////////////////////////////////////////////////////////////

*Unlocking
  -unlocking bolt (animation + sound)

{
  playAnimation(BoltPos<animation>(boltPosChambering));
  playSound(BoltPos<sound>(boltPosChambering));

  state.next();
}

////////////////////////////////////////////////////////////////////////////////

Extracting:
  -transitionRound(Remains)FromChamberToBolt (transfer of object)

{
  animation* boltAnimation = BoltPos<animation>(boltPosExtracting);
  BindEvent(boltAnimation, END, transitionRoundFromChamberToBolt);

  playAnimation(boltAnimation);
  playSound(BoltPos<sound>(boltPosExtracting));

  state.next();
}

////////////////////////////////////////////////////////////////////////////////

Ejecting:
  -ejectRoundFromBolt (sound + particle effects + spawning object)

{
  playSound(firearm.ejectionSound);
  spawnParticleEffect(round.ejectionParticleEffects);
  spawnObject(bolt.Round);
  bolt.Round = NULL;

  state.next();
}

////////////////////////////////////////////////////////////////////////////////

*Cocking
  -ready hammer (animation + sound)

{
  playAnimation(HammerPos<animation>(hammerPosFullCock));
  playSound(HammerPos<sound>(hammerPosFullCock));

  state.next();
}

////////////////////////////////////////////////////////////////////////////////

*optional; cases where state maybe unnecessary for the core functionality of the system

MACROS
////////////////////////////////////////////////////////////////////////////////

void engageEntireTrigger()
{
  setTriggerEngagement(0.0f);
}

void manualUnchamber()
{
  if(state.current == state.chambering)
  {
  }
}

//param val - value between 0.0f and 1.0f
void checkChamber(float val)
{
  float valToUse = val;

  if(val < bolt.feedPoint)
  {
    valToUse = bolt.feedPoint;
  }

  bolt.setPos(valToUse);
}

////////////////////////////////////////////////////////////////////////////////

FUNCTIONS
////////////////////////////////////////////////////////////////////////////////
//param a: value between 0.0f and 1.0f
//          1.0f being full RELEASE
//          0.0f being full PULL
void setTrigger(float a)
{
#ifdef DEBUG
  if(a > 1.0f || a < 0.0f)
  {
    debug.log();
    return;
  }
#endif

  std::vector<struct triggerStage>::const_iterator it = ti.begin();

  while(it != ti.end())
  {
      //TODO: Work out logic in notebook
    if(a >= it->triggerPos)
    {
      break;
    }

    ++it;
  }

  if(it != ti.end())
  {
    it->activateStage();
  }
}

float distanceFromClosed()
{
  return ;
}

////////////////////////////////////////////////////////////////////////////////

DATA STRUCTURES
////////////////////////////////////////////////////////////////////////////////

//Responsible to talking to action of weapon system
struct triggerStage
{
  void activateStage();
  float triggerPos;              //value from 0.0f to 1.0f for this stage to be activated
  float rateOfPosChangeFixed;    // changeInPos / time(seconds)
  float rateOfPosChangeRelative; // seconds to get to newPos; (newPos - curPos) / time(seconds
};

//Responsible for transferring round
// ^(mag->bolt->chamber; chamber->bolt->ejectionPort)
struct bolt
{
  unsigned curStage;

    //sorted array using 'triggerPos' as key in 
  std::vector<triggerStage>ti[];

  float curPos;
  float curRateOfChange;
  class Round*;


    //TODO: Remove and use vector
  triggerStage pointOpen;
  triggerStage pointChamber;
  triggerStage pointExtract;
  triggerStage pointEject;
  triggerStage pointClose;

    //Constructor
  bolt() : curStage(0), ti(5)
  {
    ti[0] = ; //WIP

    BindEvent(pointOpen.activateStage,    pointOpen.triggerPos);
    BindEvent(pointChamber.activateStage, pointChamber.triggerPos);
    BindEvent(pointExtract.activateStage, pointExtract.triggerPos);
    BindEvent(pointEject.activateStage,   pointEject.triggerPos);
    BindEvent(pointClose.activateStage,   pointClose.triggerPos);
  }

    //returns absolute value for distance
  float distanceFromHereTo(float val)
  {
    return abs(curPos - val);
  }

  void setPos(float val)
  {
    if(val)

    //From, To, Rate
    my_lerp(curPos, val, curRateOfChange);
  }
};

struct trigger
{
  unsigned curStage;

    //sorted array using 'triggerPos' as key in 
  std::vector<triggerStage>ti[];

  enum
  {
    PULL    = 0,
    RELEASE = 1
  }
};

////////////////////////////////////////////////////////////////////////////////
